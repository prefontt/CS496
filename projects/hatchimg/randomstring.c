Grant Hatchimonji
CS 362 Random Testing Quiz

The way I chose to develop my solution was as follows:

For the inputChar() function, my approach was simple. Since the testme() function could essentially "save" its progress and not have to revert back to state = 0 each time c turned out to be an unwanted character (i.e. not the character that was needed to advance state to the next value), I felt that I could be broad in my range of random values. So I was willing to include possible return values that were never going to be valid values for c (in other words, values that were not brackets, parentheses, curly braces, space, a, or x). As such, I made my random number range anywhere from 32 to 125, which covered all of the ASCII codes of the characters that the function would need to return at some point to advance the testme() function. This resulted in a solid amount of testing of "unacceptable" values.

With inputString(), however, things were a little trickier. Since we were not advancing one character at a time anymore -- and instead, randomly stringing together 6 random values and hoping that it created the desired string of 'reset\0' -- the odds of the function ever returning the correct value decreased exponentially. As such, what I chose to do was to still randomize the string, but only draw the random values from the characters that were in the desired string (i.e. r, e, s, t, and null). So to do this, I created an array called randArray that had six indices and populated 1-5 with the characters that would be in use in the final desired string (the first index of 0 was not used). Then, I used a for loop to randomly pick from the available characters and, one at a time, place them in each of the indices of the string to be returned. Once it was done, the function returned this randomized string. This approach minimized the number of "useless" test values -- therefore greatly cutting down on iterations and time -- while still allowing an element of randomness into the testing process. If I allowed for the entire set of lowercase letter ASCII values (and the null character), the test might still be running as I write this. Instead, its last run finished at just over 9000 iterations.

As for coverage, this approach offered excellent coverage. After compiling accordingly and using gcov, the coverage stats indicated that 97.62% of the lines were executed. And in terms of branch coverage, 100% of the branches 52 were executed and 98.08% were taken at least once. Finally, 100% of the program's 10 calls were executed.